import numpy as np

import fym
from fym.core import BaseEnv, BaseSystem
from fym.utils.rot import dcm2quat, quat2dcm, angle2quat, quat2angle

import ftc

import config


cfg = config.load("models.multicopter")


class Mixer:
    """Definition:
        Mixer takes force commands and translate them to actuator commands.
        Actuator commands here mean the force generated by each rotor.
    """
    def __init__(self, d, c, b):
        rtype = cfg.mixer.rtype

        if rtype == "quad-x":
            B = np.array(
                [[b, b, b, b],
                 [-0.5*np.sqrt(2)*d, 0.5*np.sqrt(2)*d, 0.5*np.sqrt(2)*d, -0.5*np.sqrt(2)*d],
                 [0.5*np.sqrt(2)*d, -0.5*np.sqrt(2)*d, 0.5*np.sqrt(2)*d, -0.5*np.sqrt(2)*d],
                 [c, c, -c, -c]]
            )

        if rtype == "quad-+":
            B = np.array(
                [[b, b, b, b],
                 [-d, d, 0, 0],
                 [0, 0, d, -d],
                 [c, c, -c, -c]]
            )

        elif rtype == "hexa-x":
            B = np.array(
                [[b, b, b, b, b, b],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2,
                  b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2],
                 [-c, c, -c, c, c, -c]]
            )

        elif rtype == "hexa-+":
            B = np.array(
                [[b, b, b, b, b, b],
                 [0, 0, b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2,
                  b*d*np.sqrt(3)/2, -b*d*np.sqrt(3)/2],
                 [-b*d, b*d, b*d/2, -b*d/2, -b*d/2, b*d/2],
                 [-c, c, -c, c, c, -c]]
            )
            self.b_gyro = np.vstack((1, -1, 1, -1, 1, -1))

            s2 = 1/2
            s3 = np.sqrt(3)/2
            self.d_rotor = np.array([
                [d, 0, 0],
                [d*s2, -d*s3, 0],
                [-d*s2, -d*s3, 0],
                [-d, 0, 0],
                [-d*s2, d*s3, 0],
                [d*s2, d*s3, 0],
            ])

        else:
            B = np.eye(4)

        self.b = b
        self.B = B
        self.Binv = np.linalg.pinv(B)

    def inverse(self, rotors):
        return self.B.dot(rotors)

    def __call__(self, forces):
        return self.Binv.dot(forces)


class Multicopter(BaseEnv):
    """Multicopter Model
    Variables:
        pos: position in I-coord
        vel: velocity in I-coord
        quat: unit quaternion.
            Corresponding to the rotation matrix from I- to B-coord.
    """
    def __init__(self, pos, vel, quat, omega):
        super().__init__()
        self.pos = BaseSystem(pos)
        self.vel = BaseSystem(vel)
        self.quat = BaseSystem(quat)
        self.omega = BaseSystem(omega)

        fym.parser.update(cfg.physProp,
                          fym.parser.decode(cfg.physPropBy)[cfg.modelFrom])
        for k, v in fym.parser.decode(cfg.physProp).items():
            self.__setattr__(k, v)

        self.Jinv = np.linalg.inv(self.J)
        self.mixer = Mixer(d=self.d, c=self.c, b=self.b)

    def deriv(self, pos, vel, quat, omega, rotors):
        F, M1, M2, M3 = self.mixer.inverse(rotors)

        M = np.vstack((M1, M2, M3))

        m, g, J = self.m, self.g, self.J
        e3 = np.vstack((0, 0, 1))

        dpos = vel
        dcm = quat2dcm(quat)
        dvel = g*e3 - F*dcm.T.dot(e3)/m
        # DCM integration (Note: dcm; I to B) [1]
        p, q, r = np.ravel(omega)
        # unit quaternion integration [4]
        dquat = 0.5 * np.array([[0., -p, -q, -r],
                                [p, 0., r, -q],
                                [q, -r, 0., p],
                                [r, q, -p, 0.]]).dot(quat)
        eps = 1 - (quat[0]**2+quat[1]**2+quat[2]**2+quat[3]**2)
        k = 1
        dquat = dquat + k*eps*quat
        domega = self.Jinv.dot(M - np.cross(omega, J.dot(omega), axis=0))

        return dpos, dvel, dquat, domega

    def set_dot(self, t, rotors):
        states = self.observe_list()
        dots = self.deriv(*states, rotors)
        self.pos.dot, self.vel.dot, self.quat.dot, self.omega.dot = dots

    def get_d(self, W, rotors):
        rotor_n = rotors.shape[0]
        fault = W - np.eye(rotor_n)
        return self.mixer.B.dot(fault.dot(rotors))
